<body>
            <h1>Simple Time-lapse Imaging for Quantifying the Hydrostatic Production of Oxygenic Photogranules</h1>
            <p><strong>Authors:</strong> Esmee D. Joosten, JÃ©rÃ´me Hamelin, Kim Milferstedt</p>
            <h2>Abstract</h2>
            <p>Oxygenic photogranules (OPGs) are dense, three-dimensional aggregates containing a syntrophic, light-driven microbial community. Their temporal and spatial development interests microbial ecologists working at the bioprocess engineering interface, as this knowledge can be used to optimize biotechnological applications, such as wastewater treatment and biomass valorization. The method presented here enables the high-throughput quantification of photogranulation. OPGs are produced from a loose sludge-like microbial matrix in hydrostatic batch cultures exposed to light. This matrix transforms into a consolidated, roughly spherical aggregate over time. Photogranulation is quantified by time-lapse imaging coupled to automated image analysis. This allows studying the development of many OPGs simultaneously and in a fully automated way to systematically test what factors drive photogranulation. The protocol can also be used to quantify other types of (a)biotic aggregation.</p>
            <p><strong>Keywords:</strong> Oxygenic photogranules, Microbial mats, Biofilms, Aggregation, Spatialization, Photogranulation, Dynamics, Time-lapse imaging</p>
            <h2>Background</h2><p>OPGs are dense, roughly spherical aggregates with diameters of several millimeters containing a syntrophic community of heterotrophic and phototrophic microorganisms (Milferstedt <em>et al.</em>, 2017). Microbial ecologists study photogranulation to understand what factors drive the formation of the three-dimensional (3D) structure. This knowledge can be applied to steer ecosystem function towards a desired function for biotechnological processes, such as wastewater treatment and the production of value-added products (Abouhend <em>et al.</em>, 2018; Quijano <em>et al.</em>, 2017). OPGs can be produced from a sludge-like microbial matrix, <em>i.e.</em>, activated sludge from the aeration basin of a wastewater treatment plant (Milferstedt <em>et al.</em>, 2017; Park and Dolan, 2015). The transformation of this sludge takes place in closed, unagitated vials exposed to light. Over the course of several weeks, the sludge bed compacts (<em>i.e.</em>, reduces in height) and contracts (<em>i.e.</em>, reduces in diameter) and transforms into one consolidated, 3D aggregate per vial (Figure 1A). Experimental images are automatically acquired through the bottom of vials at a pre-set interval (Figure 1B) of multiple replicates simultaneously. Images are treated in ImageJ (Schneider <em>et al.</em>, 2012), extending a macro developed for the quantification of naturally occurring OPGs called cryoconite granules (Irvine-Fynn <em>et al.</em>, 2010). Dynamics of biomass contraction is calculated and plotted in the software environment R (R Core Team, 2019). This protocol enables testing photogranulation in a large number of repetitions, <em>e.g.</em>, using different sludge sources or environmental conditions to advance the understanding of photogranulation. The protocol can also be used to quantify other types of (a)biotic aggregation.<br/> <br/><img alt="" class="layerphoto" loading="lazy" src="https://en-cdn.bio-protocol.org/attached/image/20200923/20200923013741_5665.jpg" width="300"/><br/><strong>Figure 1. Typical course of photogranulation, including compaction and contraction.</strong> Note the displayed images are for illustration purposes and were not obtained with the protocol presented here. A. Temporal progression of the transformation of loose activated sludge into a consolidated OPG in a 10 ml serum bottle with an outer diameter of 24 mm (adapted from Milferstedt <em>et al.</em>, 2017). Arrows illustrate the terms compaction and contraction; B. Temporal progression of biomass contraction seen through the bottom of one well of a 24-well microplate with an outer diameter of 16 mm.</p>
        </body>

<p class="pptt" id="biaoti36937">## Materials and Reagents</p><ol class="npwtwok"><li>Fresh activated sludge from the aeration basin of a wastewater treatment plant</li><li>0.5-5 ml pipette with tips (Thermo Fisher Scientific, Finnpipette<sup>TM</sup> F1, catalog number: <a class="blackNoUnder" target="_blank"> 4641110N </a> ; 5 ml Finntip<sup>TM</sup>, catalog number: <a class="blackNoUnder" target="_blank"> 9402030 </a> )</li><li>Grid for aligning and spacing vials on scanner surface. Custom-made dark gray metal grid measuring 30.4 Ã 22.2 Ã 0.2 cm (L Ã W Ã thickness) (Figures 2A-2B)<br/>The grid should be sufficiently low so that it does not shadow the biomass from the side, <em>e.g.</em>, it should not be much higher than the thickness of the vial bottom (Figure 3A-3B). The required cut-out where to place the vials can be produced using computer numerical control (CNC) metal milling or 3D printing. You can also make the grid out of other materials, such as paper.</li><li>Light-impermeable box for covering distance between vials and light source to prevent loss of light and uncontrolled illumination. Home-made cardboard box of the approximate dimensions of 65 Ã 35 Ã 65 cm (L Ã W Ã H), enclosing the scanner and the lighting device.<br/><br/><img alt="" class="layerphoto" loading="lazy" src="https://en-cdn.bio-protocol.org/attached/image/20200923/20200923032145_2210.jpg" width="300"/><br/><strong>Figure 2. Grid.</strong> A. Grid design; B. Custom-made dark gray metal grid positioned on top of the scanner.<br/></li></ol><p class="pptt" id="biaoti36938">### Equipment</p><ol class="npwtwok"><li>1 L break resistant bottle with a wide neck for sampling (Fisher Scientific, Gosselin, catalog number: <a class="blackNoUnder" target="_blank"> 11728643 </a> )</li><li>2 L polypropylene beaker for mixing (Thermo Fisher Scientific, Nalgene, catalog number: <a class="blackNoUnder" target="_blank"> 1201-2000 </a> )</li><li>4 ml clear glass vials measuring 15 mm Ã 45 mm Ã 8 mm (outer diameter Ã height Ã inner diameter) with a screw top for cultivations (Sigma-Aldrich, Supelco, catalog number: 27111) (Figure 3A)<br/>A clear, smooth and flat bottom is critical for the success of this experiment (Figure 3C). We used glass vials here, and successfully used polystyrene vials previously.</li><li>Screw caps with a contrasting color to the biomass for image treatment (Agilent Technologies, catalog number: <a class="blackNoUnder" target="_blank"> 5183-4305 </a> )</li><li>Magnetic stirrer and stir bar (Bioblock Scientific, <a class="blackNoUnder" target="_blank"> AM AMC BBS 3000 </a> ) to homogenize activated sludge so that differences in sample composition between vials are minimized</li><li>Holding device for mounting a light source, <em>e.g.</em>, copy stand with camera arm (Kaiser, RS1, RA1, catalog number: <a class="blackNoUnder" target="_blank"> 205510 </a> )</li><li>Flat light source, <em>e.g.</em>, light emitting diode (LED) panel measuring 59.5 Ã 59.5 (cropped to 30) Ã 1.06 cm (L Ã W Ã H) (Rexel, LEDVANCE, PANEL LED 600, 40W, 6500K, 4000 lm, catalog number: <a class="blackNoUnder" target="_blank"> 4058075000582 </a> )<br/>We used cool white light (6,500 K) for this experiment, but other light temperatures were also successfully tested (<em>e.g.</em>, 5,600 and 6,000 K)</li><li>Photoactive synthetically radiation (PAR) quantum light sensor and display meter system (Skye Instruments Ltd, <a class="blackNoUnder" target="_blank"> SKP 215/S 39520 </a> , <a class="blackNoUnder" target="_blank"> SKP 200 39521 </a> )</li><li>Desktop scanner (Epson, Perfection V500 Photo, model: J251A)<br/><br/><img alt="" class="layerphoto" loading="lazy" src="https://en-cdn.bio-protocol.org/attached/image/20200923/20200923032204_9470.jpg" width="300"/><br/><strong>Figure 3. Vials.</strong> A. Glass vial with screw cap; B. Vial bottom thickness; C. Clear, smooth and flat vial bottom.<br/></li></ol><p class="pptt" id="biaoti36939">### Software</p><ol class="npwtwok"><li>Scanner driver allowing time-lapse acquisition of images using a desktop scanner, <em>e.g.</em>, VueScan version 9.5.51 (Hamrick Software, <a href="https://www.hamrick.com/" target="_blank">https://www.hamrick.com/</a>)</li><li>Tool to read, write and edit meta information in batches of images, <em>e.g.</em>, ExifTool version 11.78 (Phil Harvey, <a href="https://exiftool.org/" target="_blank">https://exiftool.org/</a>)</li><li>ImageJ version 1.52a (image processing program) (National Insitutes of Health (NIH), <a href="https://imagej.nih.gov/ij/" target="_blank">https://imagej.nih.gov/ij/</a>) (Schneider <em>et al.</em>, 2012)<br/>MorphoLibJ plugin to ImageJ version 1.4.0 (collection of mathematical morphology methods and plugins) (INRA-IJPB Modeling and Digital Imaging lab, <a href="https://imagej.net/MorphoLibJ" target="_blank">https://imagej.net/MorphoLibJ</a>) (Legland <em>et al.</em>, 2016).</li><li>R version 3.6.0 (software environment for statistical computing and graphics) (R Core Team, <a href="https://www.r-project.org/" target="_blank">https://www.r-project.org/</a>) (R Core Team, 2019)<br/>exiftoolr package version 0.1.3 (OâBrien, 2020)<br/>ggplot2 package version 3.2.0 (Wickham, 2016)<br/>plyr package version 1.8.4 (Wickham, 2011)<br/>readr package version 1.3.1 (Wickham <em>et al.</em>, 2018)<br/></li></ol><p class="pptt" id="biaoti36940">### Procedure</p><p class="ppzz">The steps below describe the production of OPGs in hydrostatic batch cultivations and the automated time-lapse acquisition of experimental images. The image analysis follows at âData analysisâ.</p><ol class="npwone"><li>Scanner setup (Figures 4A-4B)<ol class="npwtwo"><li>Connect a scanner to a computer and install scanner driver, <em>e.g.</em>, VueScan.</li><li>Set scanner settings and save program.<ol class="npwthree"><li>24-bit RGB image.</li><li>800 dots per inch (dpi) resolution yielding a pixel size of 32 Âµm. This resolution is sufficient to resolve the biological process and prevents the generation of excessively large files.</li><li>Make sure there is no automatic color correction because this will complicate subsequent data analysis.</li><li>Select the uncompressed Tagged Image File Format (TIFF) for saving images.</li><li>Assign TIFF file names, <em>e.g.</em>, YY-MM-DD_01+.tif and directory to save acquired scans.</li><li>Set acquisition interval. Eight hours were sufficient to capture the dynamics of photogranulation. The interval can be increased as the experiment progresses.</li></ol></li><li>Take scanner image with a plain white sheet on top of the grid. This will be the background image for data analysis (Figure 5A).<br/><br/><img alt="" class="layerphoto" loading="lazy" src="https://en-cdn.bio-protocol.org/attached/image/20200923/20200923032322_7087.jpg" width="300"/><br/><strong>Figure 4. Experimental setup.</strong> A. Light source and scanner setup (Note the cardboard box is not shown); B. Close-up of scanner setup with vials positioned on the grid.<br/><br/></li></ol></li><li>Light source setup (Figures 4A-4B)<ol class="npwtwo"><li>Install a flat light source above a scanner, preferably using a device that allows adjusting the distance between the light source and vials, for example by connecting it to the camera arm of a copy stand. A flexible distance makes it possible to adjust the light intensity that vials receive and allows easy placement and removal of vials.</li><li>Light intensity is typically not homogeneously distributed over a LED panel. To ensure that the local light conditions are known, you can map local PAR at different points on the scanner surface, draw a contour map and decide where to place the vials, <em>e.g.</em>, along contour lines of similar light intensities. You can design a grid with circles that indicate where to place the vials (Figure 2A). You can print the grid on paper, cut out the circles and place it on top of the desktop scanner for positioning the vials. If you want to use the grid regularly, you can make it out of a more solid material, <em>e.g.</em>, metal (Figure 2B) using CNC metal milling or 3D printing.</li><li>Adjust the distance between the vials and light source such that the light intensity at the vial positions corresponds to approximately 60 ÂµmolÂ·m<sup>2</sup>Â·s<sup>-1</sup> PAR. This can be measured using a PAR quantum light sensor.<br/><br/></li></ol></li><li>Activated sludge sampling and characterization<ol class="npwtwo"><li>Sample 200 ml of activated sludge from the aeration basin of a wastewater treatment plant. This volume is largely sufficient for an experiment using 72 vials inoculated with 1.5 ml of activated sludge each, as described in the following. The sample volume needs to be adapted if you are interested in characterizing the activated sludge, <em>e.g.</em>, total and volatile solids, chemical oxygen demand, nitrogen, phosphorus, pH, chlorophyll, microbial community.</li><li>It is useful to have available the measurement of total solids. This can be used to adjust the sludge concentration to a value comparable between experiments. We typically run an experiment with a concentration between 4 and 5 g/L of activated sludge.<br/><br/></li></ol></li><li>Vial preparation and placement<ol class="npwtwo"><li>Keep activated sludge in suspension upon arrival at the lab, <em>e.g.</em>, using a magnetic stirrer.<br/><em>Note: Sludge can be stored at 4 Â°C when it cannot be used directly, but we recommend to use fresh activated sludge.</em> </li><li>Pipette 1.5 ml well-mixed activated sludge into 4 ml vials. Close vials with a screw cap. Our typical incubation set contains 72 vials.</li><li>Place vials unagitated at the assigned areas on top of desktop scanner under constant light illumination at ambient room temperature (22-26 Â°C) (Figures 4A-4B).</li><li>Place a light-impermeable box around the scanner and light source to limit loss of light and uncontrolled illumination of your samples.<br/><br/></li></ol></li><li>Vial incubation and time-lapse imaging<ol class="npwtwo"><li>Start scanner software to take an image of the bottom of the vials at the desired interval. Make sure the scanner takes an image at time 0 and that images are taken at indicated intervals.</li><li>The unconsolidated sludge transforms into one OPG per vial that is typically situated at the bottom of the vial, unless it starts floating due to attached gas bubbles. Run the experiment until mature OPGs have been formed. A mature OPG is roughly spherical and remains its shape after vigorous shaking. Under the given experimental conditions, photogranulation can be expected to occur between three to six weeks. The experimental conditions, <em>e.g.</em>, light intensity and sludge characteristics, may influence the time needed for photogranulation.</li><li>Take a final scan before removing the vials from the scanner.<br/><br/></li></ol></li><li>Photogranulation success<ol class="npwtwo"><li>Note down whether OPGs are sitting on the bottom or floating for image analysis.</li><li>Take camera images of OPGs to remember later what they looked like.</li><li>Shake vials vigorously and note down in which vials a successful OPG has been formed. Photogranulation success is the percentage of successful OPGs among the total incubated vials.</li><li>Characterize OPGs depending on the factors you are interested in, <em>e.g.</em>, physicochemical parameters, microbial community.</li></ol></li></ol><p class="pptt" id="biaoti36941">### Data analysis</p><p class="ppzz">For data analysis, we show the results of an experiment performed with 72 vials of a volume of 4 ml using two sludge sources, therefore having 36 replicates per condition. Some files are created as preparation for automatic data treatment (Procedures A-B). Experimental time-lapse images are treated in ImageJ (Schneider <em>et al.</em>, 2012) using particle size analysis to measure particle characteristics including surface area (Procedures C-D). The surface area is subsequently transformed to equivalent diameters in the software environment R (R Core Team, 2019) and plotted over time. The decrease in equivalent diameter per sample is a measure for proceeding photogranulation (Procedure E). Text in green are comments from the authors, text in red require user input, text in blue show files that will be imported into R (Procedure E).</p><ol class="npwone"><li>Experimental conditions<ol class="npwtwo"><li>Create a text file (<span style="color:#00D5FF;">experimental_conditions.txt</span>) containing the vial positions and their respective experimental conditions in three columns, <em>i.e.</em>, Location, ExpCondition, ExpID. You can find an example of this file at <a href="https://doi.org/10.5281/zenodo.3938457" target="_blank">https://doi.org/10.5281/zenodo.3938457</a>.<br/><br/></li></ol></li><li>Extract acquisition date/ time and remove scan resolution <br/><ol class="npwtwo"><li>The Exchangeable Image File (EXIF) data of the scanner images contains the filename and the creation date of the image. Both need to be available in a separate file for subsequent plotting of the data. You can automatically extract filename (<em>e.g.</em>, 2018-03-14-01.tif) and creation date/ time (<em>e.g.</em>, 2018:03:14 16:47:36) from EXIF data using the R script below. </li><li>The EXIF data may also contain the scan resolution. This resolution in dpi interferes with the particle size quantification using ImageJ. Remove scan resolution from EXIF data running ExifTool from within R so that ImageJ does not use dpi as a scaling factor. You can later assign a measurement unit to the images in ImageJ. <br/><ol class="npwthree"><li>Install ExifTool.</li><li>Open a new R script in an R editor, for example RStudio, by clicking on âfileâ, ânew fileâ, âR scriptâ.</li><li>Copy the following script into the source window. Text in red require user input and adaptations.</li></ol><br/><span style="font-family:Courier New;color:#009900;">##Packages --------------------------------------</span><br/><span style="font-family:Courier New;"><span style="font-family:Courier New;">require(exiftoolr) </span><span style="color:#009900;font-family:Courier New;">#(OâBrien, 2020)</span></span><br/><br/><span style='font-family:"color:#009900;'><span style="font-family:Courier New;color:#009900;">##Working directory ----------------------</span><span style="font-family:Courier New;color:#009900;">----------------</span></span><br/><span style="font-family:Courier New;">rm(list=ls()) </span><br/><span style="font-family:Courier New;"><span style="font-family:Courier New;">directory &lt;- ("/</span><span style="color:#E53333;font-family:Courier New;">path-to-directory/</span><span style="font-family:Courier New;">") </span></span><br/><span style="font-family:Courier New;">setwd(directory) </span><br/><br/><span style="font-family:Courier New;color:#009900;">##Extract acquisition date/ time and remove scan resolution --------------------------------------</span><br/><span style="font-family:Courier New;"><span style="font-family:Courier New;">image.vec &lt;- list.files(directory, pattern = ".tif") </span><span style="color:#009900;font-family:Courier New;">#Generates a list of all *.tif files in the directory</span></span><br/><span style="font-family:Courier New;"><span style="font-family:Courier New;">exif.images &lt;- exif_read(path = image.vec) </span><span style="color:#009900;font-family:Courier New;">#Reads the EXIF data from the specified *.tif images</span></span><br/><span style="font-family:Courier New;">image.data &lt;- cbind(exif.images$FileName, exif.images$CreateDate)</span><br/><span style="font-family:Courier New;">colnames(image.data) &lt;- c("Name", "DateTime")</span><br/><span style="font-family:Courier New;">write.csv(image.data, file = "</span><span style="color:#00D5FF;font-family:Courier New;">image_acquisition.csv</span><span style="font-family:Courier New;">", quote = F, row.names = F) #</span><span style="color:#009900;font-family:Courier New;">Writes the tags file name and creation date to a separate file to be used later. You can find an example of this file at</span><span style="font-family:Courier New;"> <a href="https://doi.org/10.5281/zenodo.3938457" target="_blank">https://doi.org/10.5281/zenodo.3938457</a>.</span><br/><span style="font-family:Courier New;"><span style="font-family:Courier New;">exiftool_cmd &lt;- paste("exiftool -ResolutionUnit= -XResolution= -YResolution= ", "*.tif",sep='') </span><span style="color:#009900;font-family:Courier New;">#Defines the ExifTool command to erase the Resolution data in the EXIF data of all images with the *.tif extension</span></span><br/><span style='font-family:"'><span style="font-family:Courier New;">system(exiftool_cmd) </span><span style="color:#009900;font-family:Courier New;">#Executes ExifTool from within R. You can also run ExifTool outside R. Original scanner images are automatically saved as *.tif_original by ExifTool. Created images without scan resolution (*.tif) will be used for subsequent data analysis in this protocol.</span></span> </li></ol></li></ol><p class="ppzz"><br/>The method presented below shows an example of how to define and measure regions of interest. ImageJ macros are adapted from Irvine-Fynn <em>et al.</em> (2010) who quantified granule geometry of cryoconite, microbial aggregates that share similarities with OPGs, under laboratory conditions. Extracting information from experimental time-lapse images is a means to an end and not the main interest of this protocol. Other methods may be used equally well to obtain particle characteristics, including area and X-, Y-coordinates.<br/><br/></p><ol class="npwone" start="3"><li>Marker image<ol class="npwtwo"><li>Here we convert the background image (Figure 5A) into a marker image (Figure 5B). The marker image will be used to determine the X-, Y-coordinates of areas that could possibly contain particles, <em>i.e.</em>, the circles that vials occupy. These data are used to assign measured particle characteristics to unique samples and their respective experimental conditions (Procedure E).<ol class="npwthree"><li>Open an empty macro in ImageJ by clicking on âpluginsâ, ânewâ, âmacroâ.<br/></li><li>Copy the following script into the macro.txt window.<br/><br/><span style="font-family:Courier New;">jobdirectory = getDirectory("Please choose a directory for saving result files and the marker image.");</span><br/><span style="font-family:Courier New;">waitForUser("Please open the background image. Then click ok."); </span><br/><span style="font-family:Courier New;">backgroundimage = getTitle();</span><br/><span style="font-family:Courier New;">run("Split Channels");</span><br/><span style="font-family:Courier New;">selectImage(backgroundimage + " (red)");</span><br/><span style="font-family:Courier New;">close();</span><br/><span style="font-family:Courier New;">selectImage(backgroundimage + " (green)");</span><br/><span style="font-family:Courier New;">close();</span><br/><span style="font-family:Courier New;">selectImage(backgroundimage + " (blue)");</span><br/><span style="font-family:Courier New;color:#009900;">//Converts RGB to grayscale image. Retains only the channel which presents most contrast between the areas on which vials are placed (white) and the grid (black).</span><br/><span style="font-family:Courier New;">run("Invert");</span><br/><span style="font-family:Courier New;color:#009900;"> //Vial areas now appear black and the grid white.</span><br/><span style="font-family:Courier New;">setAutoThreshold("Default");</span><br/><span style="font-family:Courier New;">run("Threshold...");</span><br/><span style="font-family:Courier New;">waitForUser("Please set the threshold manually. Then press OK.");</span><br/><span style="font-family:Courier New;">setOption("BlackBackground", false);</span><br/><span style="font-family:Courier New;">run("Convert to Mask");</span><br/><span style="font-family:Courier New;">run("Close");</span><br/><span><span style="font-family:Courier New;color:#009900;">//Creates binary image from grayscale image: choose and apply cut-off value to divide image into foreground, </span><em><span style="font-family:Courier New;color:#009900;">i.e.</span></em><span style="font-family:Courier New;color:#009900;">, vial areas, and background, </span><em><span style="font-family:Courier New;color:#009900;">i.e.</span></em><span style="font-family:Courier New;color:#009900;">, grid. This works well when the grid is darker than the biomass. Otherwise you will have to setOption (âBlack backgroundâ, true).</span></span><br/><span style="font-family:Courier New;">run("Fill Holes (Binary/Gray)");</span><br/><span><span style="font-family:Courier New;color:#009900;">//Fills holes in areas occupied by vials to achieve a solid area (Legland </span><em><span style="font-family:Courier New;color:#009900;">et al.</span></em><span style="font-family:Courier New;color:#009900;">, 2016).</span></span><br/><span style="font-family:Courier New;">run("Morphological Filters", "operation=Opening element=Disk radius=10");</span><br/><span style="font-family:Courier New;color:#009900;">//Removes isolated pixels and breaks connections between areas occupied by vials and the grid so that it becomes less likely that the grid is accidentally considered part of the vial area.</span><br/><span style="font-family:Courier New;">run("Morphological Filters", "operation=Erosion element=Disk radius=35");</span><br/><span><span style="font-family:Courier New;color:#009900;">//Decreases the size of detected particles to exclude areas that are not part of the biomass, </span><em><span style="font-family:Courier New;color:#009900;">e.g.</span></em><span style="font-family:Courier New;color:#009900;">, a ring corresponding to a vial that connects the biomass to the grid, resulting in a larger biomass particle than it actually is. </span></span><br/><span style="font-family:Courier New;color:#009900;"><em>//Note: You may adjust the parameter disk radius depending on your images and experiment.</em></span><br/><span style="font-family:Courier New;">saveAs("Tiff", jobdirectory + "marker.tif");</span><br/><span style="font-family:Courier New;">run("Set Measurements...", "area centroid fit shape display redirect=None decimal=3");</span><br/><span style="font-family:Courier New;color:#009900;">//Specifies which measurements are recorded.</span><br/><span style="font-family:Courier New;">run("Analyze Particles...", " show=Overlay display exclude");</span><br/><span><span style="font-family:Courier New;color:#009900;">//Generates a result table containing information about each particle in the image, including a running number to label detected particles (</span><em><span style="font-family:Courier New;color:#009900;">i.e.</span></em><span style="font-family:Courier New;color:#009900;">, the area that a vial occupies), the particle area and the centroid X-, Y-coordinates of the particles (Figure 6). It furthermore overlays the particle labels with the marker image to visually relate the particle characteristics in the table to the detected particles on the image.</span></span><br/><span><span style="font-family:Courier New;">saveAs("Results", jobdirectory + "</span><span style="color:#00D5FF;font-family:Courier New;">results_marker.csv</span><span style="font-family:Courier New;">");</span></span><br/><span><span style="color:#009900;font-family:Courier New;">//You can find an example of this file at</span><span style="font-family:Courier New;"> <a href="https://doi.org/10.5281/zenodo.3938457" target="_blank">https://doi.org/10.5281/zenodo.3938457</a>.</span></span><br/><span></span><br/></li><li>Run the macro by clicking on âmacrosâ, ârun macroâ. During execution of the macro, manually select the output directory to save the created marker image and open the background image. You can use your own background image or run a demo with the image that can be downloaded from <a href="https://doi.org/10.5281/zenodo.3938457" target="_blank">https://doi.org/10.5281/zenodo.3938457</a>.</li><li>Take a screenshot of the resulting marker image with particle labels overlaid that is not automatically saved running the macro (Figure 5B). We numbered vial locations 1 to 72 from top left to bottom right. The order in which ImageJ detected the areas occupied by vials on the marker image does not necessarily correspond to this numbering as the particle analyzer in ImageJ scans the image until it finds an edge of an object, which becomes particle 1 (see number 1 in Figure 5B), which in this case also corresponds to location 1 according to our numbering. In the R script (Procedure E1b), we use the screenshot to relate ImageJ particle numbers (lines in result table) to our vial locations.<br/><br/><img alt="" class="layerphoto" loading="lazy" src="https://en-cdn.bio-protocol.org/attached/image/20200923/20200923032947_4302.jpg" width="300"/><br/><strong>Figure 5. Marker image created from background image.</strong> Screenshots of A. the background image, that is converted into B. the marker image, here displayed with the particle label overlay. The images that are saved in the macro do not have the headers and overlay as displayed in this figure. Columns are indicated in blue and rows in green.<br/><br/><img alt="" class="layerphoto" loading="lazy" src="https://en-cdn.bio-protocol.org/attached/image/20200923/20200923032958_3847.jpg" width="300"/><br/><strong>Figure 6. Result table of marker image.</strong> Screenshot of the result table showing characteristics of the first 15 out of 72 particles of the marker. This is not the result table that is saved in the macro, which is a comma-separated value (csv) file.<br/><br/></li></ol></li></ol></li><li>Experimental time-lapse images<ol class="npwtwo"><li>Here we convert scanner color images to black and white binary images, displaying biomass particles in black and the grid in white. Characteristics of each particle will be saved in a corresponding result table. The grid for positioning the vials will be automatically removed from the images. Possible erratic particles that are not part of the OPGs are equally removed during the process. The macro includes a manual thresholding step which is relatively time-consuming, but automatic thresholding may not always result in particles that reflect well the visual impression on the scanner images. In theory, we obtain 72 biomass particles per image for an incubation set of 72 vials. We acquired experimental images over a period of six weeks, resulting in 110 color images, each of a size of 182 MB. An image that is taken halfway through the experiment is shown as an example in Figure 7A.<ol class="npwthree"><li>An image containing the background (<em>i.e.</em>, areas that cannot possibly contain biomass, for example the grid) is required. This image needs to be a grayscale image in which the grid is white and the areas potentially containing particles during the experiment are black. In the simplest case, the image could be the marker image generated in Procedure C, or, for improved particle detection, a manually curated image based on either the background or an experimental image. During manual curation, the area available for photogranulation may be redrawn as disks with the inner diameter of the vials. A foreground limited to the potential areas where particles can be detected avoids artefacts interfering with image detection that can be caused by reflections of the vial walls or shadowing effects of the grid during scanning.</li><li>Open an empty macro in ImageJ by clicking on âpluginsâ, ânewâ, âmacroâ.</li><li>Copy the following script into the macro.txt window.<br/><br/><span style="font-family:Courier New;">setBatchMode(false); </span><br/><span style="font-family:Courier New;color:#009900;">//Enters or remains in batch mode and hide active images during macro execution.</span><br/><span style="font-family:Courier New;">function action(input, output, filename){</span><br/><span style="font-family:Courier New;"> open(input + filename); </span><br/><span style="font-family:Courier New;"> jobname = getTitle(); </span><br/><span style="font-family:Courier New;">jobnamemod = indexOf(jobname, "."); </span><br/><span style="font-family:Courier New;"> jobname = substring(jobname, 0, jobnamemod);</span><br/><span style="font-family:Courier New;color:#009900;">//The file paths and filenames entered when starting the macro are converted to variables that become useable to the commands where they are used.</span><br/><span style="font-family:Courier New;"> run("Split Channels"); </span><br/><span style="font-family:Courier New;"> selectImage(jobname + ".tif (blue)");</span><br/><span style="font-family:Courier New;">close();</span><br/><span style="font-family:Courier New;"> selectImage(jobname + ".tif (green)");</span><br/><span style="font-family:Courier New;"> close();</span><br/><span style="font-family:Courier New;"> selectImage(jobname + ".tif (red)");</span><br/><span style="font-family:Courier New;"> red_image = getTitle();</span><br/><span style="font-family:Courier New;color:#009900;"> //Converts RGB to grayscale image. Retains only the channel which presents most contrast between the areas on which vials are placed (white) and the grid (black).</span><br/><span style="font-family:Courier New;"> open(path);</span><br/><span style='font-family:"color:#009900;'><span style="font-family:Courier New;color:#009900;">//Opens the grid image (</span><em><span style="font-family:Courier New;color:#009900;">e.g.</span></em><span style="font-family:Courier New;color:#009900;">, the marker image) selected in Procedure D1a using the file specified below. </span></span><br/><span style="font-family:Courier New;color:#009900;">//Vial areas now appear blackish and the grid whitish. </span><br/><span style="font-family:Courier New;">grid = getTitle(); </span><br/><span style="font-family:Courier New;"> imageCalculator("Add create", red_image, grid);</span><br/><span style="font-family:Courier New;">close("\\Others");</span><br/><span style="font-family:Courier New;color:#009900;">//Making grid appear as true white so that it will be detected as background in the subsequent binarization step.</span><br/><span style="font-family:Courier New;"> run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel"); </span><br/><span style='font-family:"color:#009900;'><span style="font-family:Courier New;color:#009900;">//Removes spatial scale of active image so that measurement results (</span><em><span style="font-family:Courier New;color:#009900;">e.g.</span></em><span style="font-family:Courier New;color:#009900;">, area measurements) have the unit pixel.</span></span><br/><span style="font-family:Courier New;"> run("Threshold..."); </span><br/><span style="font-family:Courier New;"> waitForUser("Please set the threshold manually. Then press OK, or cancel to exit macro");</span><br/><span style="font-family:Courier New;">setOption("BlackBackground", false);</span><br/><span style="font-family:Courier New;"> run("Convert to Mask");</span><br/><span style="font-family:Courier New;">selectWindow("Threshold");</span><br/><span style="font-family:Courier New;"> run("Close");</span><br/><span style='font-family:"color:#009900;'><span style="font-family:Courier New;color:#009900;">//Creates binary image from grayscale image: choose and apply cut-off value to divide image into foreground, </span><em><span style="font-family:Courier New;color:#009900;">i.e.</span></em><span style="font-family:Courier New;color:#009900;">, vial areas, and background, </span><em><span style="font-family:Courier New;color:#009900;">i.e.</span></em><span style="font-family:Courier New;color:#009900;">, grid. Define your own criteria and try to treat each image of your dataset in the same way.</span></span><br/><span style='font-family:"color:#009900;'><span style="font-family:Courier New;color:#009900;">//</span><em><span style="font-family:Courier New;color:#009900;">Note: This can be tricky because we normally do not find a threshold that works ideally for every particle on an image. We recommend testing a small subset (e.g., first, middle and last images) to get an idea of what works well. </span></em></span><br/><span style="font-family:Courier New;">run("Fill Holes (Binary/Gray)");</span><br/><span style='font-family:"color:#009900;'><span style="font-family:Courier New;color:#009900;">//Fills holes in the areas occupied by vials to achieve a solid area (Legland </span><em><span style="font-family:Courier New;color:#009900;">et al.</span></em><span style="font-family:Courier New;color:#009900;">, 2016). </span></span><br/><span style='font-family:"color:#009900;'><span style="font-family:Courier New;color:#009900;">//</span><em><span style="font-family:Courier New;color:#009900;">Note: This may fill up entire vial area when a biomass particle is surrounded by a ring corresponding to a vial. If this happens, you can reduce the size of the respective particle on the marker image using for example image editor Gimp and run the macro again (see also Procedure D1a).</span></em> </span><br/><span style="font-family:Courier New;"> run("Morphological Filters", "operation=Opening element=Disk radius=10"); </span><br/><span style="font-family:Courier New;">close("\\Others");</span><br/><span style='font-family:"'><span style="font-family:Courier New;color:#009900;"> //Removes isolated pixels and breaks connections between areas occupied by vials and the grid so that it becomes less likely that the grid is accidentally considered part of the vial area.</span><br/><span style="font-family:Courier New;"> mask_image = getTitle(); </span><br/><span style="font-family:Courier New;color:#009900;">//Created image becomes mask image.</span><br/><span style="font-family:Courier New;"> run("Morphological Filters", "operation=Erosion element=Disk radius=40");</span><br/><span style="font-family:Courier New;"> marker_image = getTitle();</span><br/><span style="font-family:Courier New;color:#009900;"> //Drastically decreases the size of detected particles on the mask image to create an image that will be used for morphological reconstruction.<br/>//<em>Note: Images of small granules may be removed when the disk radius is too large, you may adjust the parameter disk radius depending on your images and experiment.</em></span><br/><span style="font-family:Courier New;"> print("The marker image name is " + marker_image); </span><br/><span style="font-family:Courier New;"> print("The mask image name is " + mask_image);</span><br/><span style="font-family:Courier New;color:#009900;">//Prints active marker and mask images.</span><br/><span style="font-family:Courier New;"> run("Morphological Reconstruction", "marker=["+marker_image+"] mask=["+mask_image+"] type=[By Dilation] connectivity=4");</span><br/><span style="font-family:Courier New;color:#009900;">//Keeps particles from the mask image that overlap with at least one pixel on the marker image and remove other pixels. This step assures that only particles are retained that overlap with vial areas and that possible erratic particles that are not part of OPGs are removed.</span><br/><span style="font-family:Courier New;"> run("Set Measurements...", "area centroid fit shape display redirect=None decimal=3");</span><br/><span style="font-family:Courier New;"> rename(jobname); </span><br/><span style="font-family:Courier New;color:#009900;">//Specifies which measurements are recorded.</span><br/><span style="font-family:Courier New;"> run("Analyze Particles...", "size=0-Infinity circularity=0.00-1.00 show=[Overlay Outlines] display exclude");</span><br/><span style="font-family:Courier New;color:#009900;">//Generates result table (see explanation at Procedure C).</span><br/><span style="font-family:Courier New;"> save(output + jobname + ".final.tif");</span><br/><span style="font-family:Courier New;"> close();</span><br/><span style="font-family:Courier New;"> saveAs("Results", output+ jobname + "_results.csv" ); </span><br/><span style="font-family:Courier New;"> run("Clear Results"); </span><br/><span style="font-family:Courier New;"> selectWindow("Log");</span><br/><span style="font-family:Courier New;"> run("Close All");</span><br/><span style="font-family:Courier New;"> }</span><br/><span style="font-family:Courier New;color:#009900;">//Erases any previous measurement results.</span><br/><span style="font-family:Courier New;"> input = getDirectory("Choose an input directory with the raw images, please.");</span><br/><span style="font-family:Courier New;"> output = getDirectory("Choose an output directory for result images and tables, please.");</span><br/><span style="font-family:Courier New;"> waitForUser("Please open the grid image. Then click ok.");</span><br/><span style="font-family:Courier New;color:#009900;">//Selects the grid image (<em>e.g.</em>, the marker image) selected in Procedure D1a. This image allows the removal of the grid from the scanner images.</span><br/><span style="font-family:Courier New;"> grid = getTitle();</span><br/><span style="font-family:Courier New;"> dir = getDirectory("image");</span><br/><span style="font-family:Courier New;"> path = dir+grid;</span><br/><span style="font-family:Courier New;"> close(); </span><br/><span style="font-family:Courier New;color:#009900;">//Define input directory with experimental images and output directory to save created images. Open the grid image selected in Procedure D1a. In the chronology of the script, results from these commands will be displayed once when starting the macro. </span><br/><span style="font-family:Courier New;"> list = getFileList(input);</span><br/><span style="font-family:Courier New;"> for (i = 0; i &lt; list.length; i++)</span><br/><span style="font-family:Courier New;"> action(input, output, list[i]);</span><br/><span style="font-family:Courier New;"> setBatchMode(false);</span><br/><span style="font-family:Courier New;color:#009900;">//Definition of a loop structure that will execute the macro function as many times as there are images found in the input directory.</span><br/><br/></span> </li><li>Run the macro by clicking on âmacrosâ, ârun macroâ. During execution of the macro, manually select the input directory with experimental images, output directory to save created images and open the grid image selected in Procedure D1a. You can use your own experimental images and grid image or run a demo with exemplary images that can be downloaded from <a href="https://doi.org/10.5281/zenodo.3938457" target="_blank">https://doi.org/10.5281/zenodo.3938457</a>. Actions are automatically repeated for all images in the input directory.<br/><em>Note: Make sure to not have unrelated files in the folder as otherwise ImageJ attempts to treat them as images.</em> </li><li>Manually check whether the particles on the obtained images (Figure 7B) correspond to what you visually detect on the raw images.<br/><em>Note: This sanity check is important because the automated analysis is supposed to mimic and automate the visual inspection but is not infallible. You can create a series of thumbnails by rescaling the original scanner images to a reduced size to browse more easily through the images.</em> </li><li>Concatenate (combine) result tables into one csv file to simplify the analysis.<br/><ol class="npwfour"><li>Open a new R script in an R editor, for example RStudio (R Core Team, 2019), by clicking on âfileâ, ânew fileâ, âR scriptâ.</li><li>Copy the following script into the source window. Text in red require user input and adaptations.<br/><br/><span style="font-family:Courier New;color:#009900;">##Packages --------------------------------------</span><br/><span style="font-family:Courier New;">require(plyr)</span> <span style="font-family:Courier New;color:#009900;">#(Wickham, 2011)</span> <br/><span style="font-family:Courier New;">require(readr)</span> <span style="font-family:Courier New;color:#009900;"> #(Wickham et al., 2018)</span><br/><br/><span style="font-family:Courier New;color:#009900;">##Working directory --------------------------------------</span><br/><span style="font-family:Courier New;">rm(list=ls()) </span><br/><span style="font-family:Courier New;">directory &lt;- ("</span><span style="font-family:Courier New;color:#E53333;">/path-to-directory/</span>") <br/><span style="font-family:Courier New;">setwd(directory) </span><br/><br/><span style="font-family:Courier New;color:#009900;">##Concatenate result tables --------------------------------------</span><br/><span style="font-family:Courier New;">results.df &lt;- list.files(path = directory, pattern = "*.csv", full.names = T) <span style="color:#009900;">#Generates a list of all *.csv files in the directory</span></span><br/><span style="font-family:Courier New;">results.df &lt;- ldply(results.df, read_csv) <span style="color:#009900;">#Combines result tables of all images into a single data frame</span></span><br/><span style="font-family:Courier New;">colnames(results.df)[1] &lt;- "ObjNum" <span style="color:#009900;">#Assigns name ObjNum to first column</span></span><br/><span style="font-family:Courier New;">write.csv(results.df, file = "<span style="color:#00D5FF;">results_scanner_images.csv</span>", quote = F, row.names = F) <span style="color:#009900;">#Writes result tables of all images to a separate file to be used later. You can find an example of this file at</span> <a href="https://doi.org/10.5281/zenodo.3938457" target="_blank">https://doi.org/10.5281/zenodo.3938457</a>.</span><br/></li></ol><br/><img alt="" class="layerphoto" loading="lazy" src="https://en-cdn.bio-protocol.org/attached/image/20200923/20200923193041_9962.jpg" width="300"/><br/><strong>Figure 7. Result image created from scanner image.</strong> Screenshots of A. a scanner image taken halfway through the experiment, that is converted into B. the result image for which the particle characteristics are determined. The images show particles contracted to varying degrees for the two sludge sources. The images that are saved in the macro do not have the headers as displayed in this figure.</li></ol><br/></li></ol></li><li>Quantification of photogranulation<br/><ol class="npwtwo"><li>The experimental results are now imported into the software environment R (R Core Team, 2019). The challenge is to automatically convert the particle characterizations done per image into one time series per vial. The steps of the R script are as follows:<br/>â¢Calculate average X-, Y-coordinates of vial areas identified on the marker image (Figure 5B);<br/>â¢Assign experimental time to all experimentally measured particles per image by adding a column with experimental time to the particle data obtained with ImageJ. This facilitates the plotting to temporal dynamics;<br/>â¢Identify particles from a vial at a specific physical location on each image using the X-, Y-coordinates of vial areas. Relate particles to their location by assigning a location number and match them to the appropriate experimental conditions;<br/>â¢Transform the detected surface area of particles into equivalent diameters;<br/>â¢Plot the average decrease in particle diameter per experimental condition over time.<br/><ol class="npwthree"><li>Open a new R script in an R editor, for example RStudio, by clicking on âfile, ânew fileâ, âR scriptâ.</li><li>Copy the following script into the source window. Text in red require user input and adaptations.<br/><br/><span style="color:#009900;font-family:Courier New;">##Packages --------------------------------------</span><br/><span style="font-family:Courier New;"> require(plyr) </span><span style="color:#009900;font-family:Courier New;">#(Wickham, 2011)</span><br/><span style="font-family:Courier New;"> require(ggplot2) </span><span style="color:#009900;font-family:Courier New;">#(Wickham, 2016) </span><br/><br/><span style="color:#009900;font-family:Courier New;">##Working directory --------------------------------------</span><br/><span style="font-family:Courier New;"> rm(list=ls()) </span><br/><span style="font-family:Courier New;"> directory &lt;- ("</span><span style="color:#E53333;font-family:Courier New;">/path-to-directory/</span><span style="font-family:Courier New;">") </span><br/><span style="font-family:Courier New;"> setwd(directory) </span><br/><br/><span style="color:#009900;font-family:Courier New;">##Start time --------------------------------------</span><br/><span style="font-family:Courier New;"> start.time &lt;- c("</span><span style="color:#E53333;font-family:Courier New;">2018:03:14 17:51:19</span><span style="font-family:Courier New;">") </span><br/><span style="color:#009900;font-family:Courier New;">#Manually enter start date/ time of the first image of the experiment. Experimental time will be calculated based on this time point, using the acquisition time of the scanner images. </span><br/><br/><span style="color:#009900;font-family:Courier New;">##Scaling factor --------------------------------------</span><br/><span style="font-family:Courier New;"> scaling.factor &lt;- </span><span style="color:#E53333;font-family:Courier New;">475.417/1.5</span><span style="color:#009900;font-family:Courier New;"> #pixels/cm</span><br/><span style="color:#009900;"><span style="font-family:Courier New;"> #Manually enter the scale of the images, </span><em><span style="font-family:Courier New;">i.e.</span></em><span style="font-family:Courier New;">, number of pixels to cover the diameter of a vial. This value can be easily measured in ImageJ. </span></span><br/><br/><span style="color:#009900;font-family:Courier New;">##Margin --------------------------------------</span><br/><span style="font-family:Courier New;"> margin.vial &lt;- 212</span><br/><span style="color:#009900;font-family:Courier New;">#Manually enter average number of pixels between the center and edges of a particle as measured in ImageJ, typically the inner radius of the vials in pixel.</span><br/><br/><span style="color:#009900;font-family:Courier New;">##Files to be imported --------------------------------------</span><br/><span style="color:#009900;font-family:Courier New;"> #You can run a demo with the files presented at</span> <a href="https://doi.org/10.5281/zenodo.3938457" target="_blank"><span style="font-family:Courier New;">https://doi.org/10.5281/zenodo.3938457</span></a><span style="font-family:Courier New;">.</span><br/><span style="font-family:Courier New;"> coordinates.name &lt;- "</span><span style="color:#00D5FF;font-family:Courier New;">results_marker.csv</span><span style="font-family:Courier New;">" </span><span style="color:#009900;font-family:Courier New;">#Information about each particle on marker image (generated using ImageJ)</span><span style="font-family:Courier New;">.</span><br/><span style="font-family:Courier New;"> raw.data.name &lt;- "</span><span style="color:#00D5FF;font-family:Courier New;">results_scanner_images.csv</span><span style="font-family:Courier New;">" </span><span style="color:#009900;font-family:Courier New;">#Joined result tables of scanner images (generated using ImageJ)</span><span style="font-family:Courier New;">.</span><br/><span style="font-family:Courier New;"> acquisition.time.name &lt;- "</span><span style="color:#00D5FF;font-family:Courier New;">image_acquisition.csv</span><span style="font-family:Courier New;">" </span><span style="color:#009900;font-family:Courier New;">#Filename and creation date of scanner images (generated using ExifTool from within R)</span><span style="font-family:Courier New;">.</span><br/><span style="font-family:Courier New;"> experimental.condition.name &lt;- "</span><span style="color:#00D5FF;font-family:Courier New;">experimental_conditions.txt</span><span style="font-family:Courier New;">" </span><span style="color:#009900;font-family:Courier New;">#Experimental conditions per sample (manually generated)</span><span style="font-family:Courier New;">.</span><br/><br/><span style="color:#009900;font-family:Courier New;">##Loading files --------------------------------------</span><br/><span style="font-family:Courier New;"> coordinates &lt;- read.csv(coordinates.name, header=T, as.is =T)</span><br/><span style="font-family:Courier New;"> raw.data &lt;- read.csv(raw.data.name, header = T, as.is = T)</span><br/><span style="font-family:Courier New;"> acquisition.time &lt;- read.csv(acquisition.time.name, header = T, as.is = T)</span><br/><span style="font-family:Courier New;"> experimental.condition &lt;- read.delim(experimental.condition.name, header = T, as.is = T)</span><br/><br/><span style="color:#009900;font-family:Courier New;">####Calculate average X-, Y-coordinates of vial areas identified on the marker image (Figure 5B).</span><br/><br/><span style="color:#009900;font-family:Courier New;"> ##Average X-, Y-coordinates of vial areas --------------------------------------</span><br/><span style="font-family:Courier New;"> column.1 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">1,14,27,40,53,66</span><span style="font-family:Courier New;">) </span><span style="color:#009900;"><span style="font-family:Courier New;">#Manually enter which particle label on the marker screenshot corresponds to which column, as indicated in blue (Figure 5B). The grid consists of columns alternating in starting position and size, </span><em><span style="font-family:Courier New;">e.g.</span></em><span style="font-family:Courier New;">, the first particle detected corresponds to the first particle in the first column of the scanner grid, the fourteenth particle detected is situated on the grid in column 1, row 3, etc.</span></span> <br/><span style="font-family:Courier New;"> column.2 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">8,21,34,47,60</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> column.3 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">2,15,28,41,54,67</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> column.4 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">9,22,35,48,61</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> column.5 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">3,16,29,42,55,68</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> column.6 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">10,23,36,49,62</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> column.7 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">4,17,30,43,56,69</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> column.8 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">11,24,37,50,63</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> column.9 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">5,18,31,44,57,70</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> column.10 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">12,25,38,51,64</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> column.11 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">6,19,32,45,58,71</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> column.12 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">13,26,39,52,65</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> column.13 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">7,20,33,46,59,72</span><span style="font-family:Courier New;">)</span><br/><br/><span style="font-family:Courier New;"> row.1 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">1,2,3,4,5,6,7</span><span style="font-family:Courier New;">) </span><span style="color:#009900;"><span style="font-family:Courier New;">#Manually enter which particle label on the marker screenshot corresponds to which row, as indicated in green (Figure 5B). The grid consists of rows alternating in starting position and size, </span><em><span style="font-family:Courier New;">e.g.</span></em><span style="font-family:Courier New;">, the first particle detected corresponds to the most left particle in the first row of the grid, etc.</span></span> <br/><span style="font-family:Courier New;"> row.2 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">8,9,10,11,12,13</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> row.3 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">14,15,16,17,18,19,20</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> row.4 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">21,22,23,24,25,26</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> row.5 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">27,28,29,30,31,32,33</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> row.6 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">34,35,36,37,38,39</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> row.7 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">40,41,42,43,44,45,46</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> row.8 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">47,48,49,50,51,52</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> row.9 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">53,54,55,56,57,58,59</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> row.10 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">60,61,62,63,64,65</span><span style="font-family:Courier New;">)</span><br/><span style="font-family:Courier New;"> row.11 &lt;- c(</span><span style="color:#E53333;font-family:Courier New;">66,67,68,69,70,71,72</span><span style="font-family:Courier New;">)</span><br/><br/><span style="font-family:Courier New;"> pos.names &lt;- c(row.1, row.2, row.3, row.4, row.5, row.6, row.7, row.8, row.9, row.10, row.11)</span><br/><span style="color:#009900;font-family:Courier New;">#Order of particle numbers from top left to bottom right.</span><br/><br/><span style="font-family:Courier New;"> average.x.1 &lt;- mean(coordinates$X[coordinates$X.1 %in% column.1])</span><br/><span style="font-family:Courier New;"> average.x.2 &lt;- mean(coordinates$X[coordinates$X.1 %in% column.2])</span><br/><span style="font-family:Courier New;"> average.x.3 &lt;- mean(coordinates$X[coordinates$X.1 %in% column.3])</span><br/><span style="font-family:Courier New;"> average.x.4 &lt;- mean(coordinates$X[coordinates$X.1 %in% column.4])</span><br/><span style="font-family:Courier New;"> average.x.5 &lt;- mean(coordinates$X[coordinates$X.1 %in% column.5])</span><br/><span style="font-family:Courier New;"> average.x.6 &lt;- mean(coordinates$X[coordinates$X.1 %in% column.6])</span><br/><span style="font-family:Courier New;"> average.x.7 &lt;- mean(coordinates$X[coordinates$X.1 %in% column.7])</span><br/><span style="font-family:Courier New;"> average.x.8 &lt;- mean(coordinates$X[coordinates$X.1 %in% column.8])</span><br/><span style="font-family:Courier New;"> average.x.9 &lt;- mean(coordinates$X[coordinates$X.1 %in% column.9])</span><br/><span style="font-family:Courier New;"> average.x.10 &lt;- mean(coordinates$X[coordinates$X.1 %in% column.10])</span><br/><span style="font-family:Courier New;"> average.x.11 &lt;- mean(coordinates$X[coordinates$X.1 %in% column.11])</span><br/><span style="font-family:Courier New;"> average.x.12 &lt;- mean(coordinates$X[coordinates$X.1 %in% column.12])</span><br/><span style="font-family:Courier New;"> average.x.13 &lt;- mean(coordinates$X[coordinates$X.1 %in% column.13])</span><br/><span style="font-family:Courier New;"> #Calculates average X-coordinates.</span><br/><br/><span style="font-family:Courier New;"> average.y.1 &lt;- mean(coordinates$Y[coordinates$X.1 %in% row.1])</span><br/><span style="font-family:Courier New;"> average.y.2 &lt;- mean(coordinates$Y[coordinates$X.1 %in% row.2])</span><br/><span style="font-family:Courier New;"> average.y.3 &lt;- mean(coordinates$Y[coordinates$X.1 %in% row.3])</span><br/><span style="font-family:Courier New;"> average.y.4 &lt;- mean(coordinates$Y[coordinates$X.1 %in% row.4])</span><br/><span style="font-family:Courier New;"> average.y.5 &lt;- mean(coordinates$Y[coordinates$X.1 %in% row.5])</span><br/><span style="font-family:Courier New;"> average.y.6 &lt;- mean(coordinates$Y[coordinates$X.1 %in% row.6])</span><br/><span style="font-family:Courier New;"> average.y.7 &lt;- mean(coordinates$Y[coordinates$X.1 %in% row.7])</span><br/><span style="font-family:Courier New;"> average.y.8 &lt;- mean(coordinates$Y[coordinates$X.1 %in% row.8])</span><br/><span style="font-family:Courier New;"> average.y.9 &lt;- mean(coordinates$Y[coordinates$X.1 %in% row.9])</span><br/><span style="font-family:Courier New;"> average.y.10 &lt;- mean(coordinates$Y[coordinates$X.1 %in% row.10])</span><br/><span style="font-family:Courier New;"> average.y.11 &lt;- mean(coordinates$Y[coordinates$X.1 %in% row.11])</span><br/><span style="color:#009900;font-family:Courier New;">#Calculates average Y-coordinates.</span><br/><br/><span style="font-family:Courier New;"> average.x.a &lt;-c(average.x.1, average.x.3, average.x.5, average.x.7, average.x.9, average.x.11, average.x.13)</span><br/><span style="font-family:Courier New;"> average.x.b &lt;- c(average.x.2, average.x.4, average.x.6, average.x.8, average.x.10, average.x.12)</span><br/><span style="color:#009900;font-family:Courier New;">#Calculates average Y-coordinates of rows having the same X-coordinate.</span><br/><span style="font-family:Courier New;"> average.y.a &lt;- c(average.y.1, average.y.3, average.y.5, average.y.7, average.y.9, average.y.11)</span><br/><span style="font-family:Courier New;"> average.y.b &lt;- c(average.y.2, average.y.4, average.y.6, average.y.8, average.y.10)</span><br/><span style="color:#009900;font-family:Courier New;">#Calculates average X-coordinates of rows having the same Y-coordinate.</span><br/><span style="font-family:Courier New;"> first.half &lt;- expand.grid(average.x.a, average.y.a) </span><br/><span style="font-family:Courier New;"> second.half &lt;- expand.grid(average.x.b, average.y.b) </span><br/><span style="color:#009900;font-family:Courier New;">#Couples X-, Y-coordinates for both a and b.</span><br/><span style="font-family:Courier New;"> average.coordinates &lt;- rbind(first.half, second.half) </span><br/><span style="font-family:Courier New;"> colnames(average.coordinates) &lt;- c("X","Y")</span><br/><span style="color:#009900;font-family:Courier New;">#Combines first.half and second.half by rows.</span><br/><span style="font-family:Courier New;"> average.coordinates &lt;- average.coordinates[order(average.coordinates$Y, average.coordinates$X),] </span><br/><span style="color:#009900;font-family:Courier New;">#Arranges coordinates to be in the same order as the particle numbers that can be found on the marker screenshot.</span><br/><span style="font-family:Courier New;"> average.coordinates &lt;- cbind(average.coordinates, pos.names, 1:72) </span><br/><span style="font-family:Courier New;"> colnames(average.coordinates) &lt;- c("X","Y", "ParticleLabel", "Location") </span><br/><span style="color:#009900;font-family:Courier New;">#Adds columns with order of particles numbers that can be found on the marker screenshot and experimental vial locations (1 to 72 from top left to bottom right).</span><br/><br/><span style="color:#009900;font-family:Courier New;"><u>####Assign experimental time to all experimentally measured particles per image by adding a column with experimental time to the particle data obtained with ImageJ. This facilitates the plotting to temporal dynamics.</u></span><br/><br/><span style="color:#009900;font-family:Courier New;">##Experimental time --------------------------------------</span><br/><span style="font-family:Courier New;"> start.time &lt;- strptime(start.time, "%Y:%m:%d %H:%M:%S") </span><br/><span style="color:#009900;font-family:Courier New;">#Converts start time to date/ time representation.</span><br/><span style="font-family:Courier New;"> date.time &lt;- strptime(acquisition.time$DateTime, "%Y:%m:%d %H:%M:%S") </span><br/><span style="color:#009900;font-family:Courier New;">#Acquires acquisition time per image and converts it to a date/ time representation.</span><br/><span style="font-family:Courier New;"> exp.time &lt;- round(-1*(as.numeric(start.time - date.time, units="hours")),3)</span><br/><span style="color:#009900;font-family:Courier New;">#Converts date/ time to experimental time.</span><br/><span style="font-family:Courier New;"> acquisition.time &lt;- cbind(acquisition.time, exp.time) </span><br/><span style="color:#009900;font-family:Courier New;">#Adds experimental time to acquisition time file.</span><br/><span style="font-family:Courier New;"> colnames(acquisition.time) &lt;- c("Name", "Date", "ExpTime") </span><br/><span style="font-family:Courier New;"> acquisition.time$Name &lt;- gsub(".tif", "", acquisition.time$Name)</span><br/><span style="color:#009900;font-family:Courier New;">#Removes *.tif from file names.</span><br/><span style="font-family:Courier New;"> unique.images &lt;- unique(raw.data$Label) </span><br/><span style="color:#009900;font-family:Courier New;">#Checks number of unique images.</span><br/><span style="font-family:Courier New;"> ExpTime.vec &lt;- rep(0, nrow(raw.data)) </span><br/><span style="color:#009900;font-family:Courier New;">#Creates vector with as many zeros as there are rows in the raw data file (equals number of particles per image times number of images).</span><br/><span style="font-family:Courier New;"> for(i in 1:length(unique.images)) </span><br/><span style="font-family:Courier New;"> {time.i &lt;- acquisition.time$ExpTime[which(acquisition.time$Name == unique.images[i])] </span><br/><span style="font-family:Courier New;"> indices.1 &lt;- which(raw.data$Label == unique.images[i]) </span><br/><span style="font-family:Courier New;"> ExpTime.vec[indices.1] &lt;- time.i} </span><br/><span style="font-family:Courier New;"> raw.data &lt;- cbind(raw.data, ExpTime.vec, rep(NA, nrow(raw.data)), rep(NA, </span><br/><span style="font-family:Courier New;"> nrow(raw.data)), rep(NA, nrow(raw.data)))</span><br/><span style="font-family:Courier New;"> colnames(raw.data)[(ncol(raw.data)-3):ncol(raw.data)] &lt;- c("ExpTime", "Location", </span><br/><span style="font-family:Courier New;"> "ExpCondition", "ExpID")</span><br/><span style="font-family:Courier New;"> raw.data &lt;- raw.data[order(raw.data$ExpTime),] </span><br/><span style="color:#009900;"><span style="font-family:Courier New;">#Loops over number of scanner images (</span><em><span style="font-family:Courier New;">i.e.</span></em><span style="font-family:Courier New;">, 110 images), gives experimental time of image in acquisition.time file that corresponds to image i. Gives rows that correspond to image raw.data file that corresponds to image i (each image typically has 72 particles). Replaces zeros in vector belonging to these rows by experimental time belonging to image i. </span></span><br/><br/><span style="color:#009900;font-family:Courier New;"><u>####Identify particles from a vial at a specific physical location on each image using the X-, Y-coordinates of vial areas. Relate particles to their location by assigning a location number and match them to the appropriate experimental conditions.</u></span><br/><br/><span style="color:#009900;font-family:Courier New;">##Identify particles per location and add experimental conditions --------------------------------------</span><br/><span style="font-family:Courier New;"> for(j in 1:nrow(average.coordinates) ){indices.2 &lt;- which(</span><br/><span style="font-family:Courier New;"> sqrt(((raw.data$X- average.coordinates$X[j])^2) + ((raw.data$Y-average.coordinates$Y[j])^2)) &lt; margin.vial) </span><br/><span style="font-family:Courier New;"> if(length(indices.2) == length(unique.images)){print(paste(c("All looks fine for Location ", j, "."), sep = "", collapse = ""))}else{print(paste(c("Warning: there is an issue for Location ", j, "."), sep = "", collapse = ""))}</span><br/><span style="color:#009900;"><span style="font-family:Courier New;">#If there is an issue for Location j, go manually through the images and make sure the issue is corrected. It may happen that a particle was not detected on all images, </span><em><span style="font-family:Courier New;">e.g.</span></em><span style="font-family:Courier New;">, because it started to float, or more than one particle has been detected in the same well on one image, </span><em><span style="font-family:Courier New;">e.g.</span></em><span style="font-family:Courier New;">, because there was a small piece of loose biomass. In the latter case, you can manually remove the data from the erroneous particle that is not a granule from the dataset.</span></span><br/><span style="font-family:Courier New;"> raw.data$Location[indices.2] &lt;- average.coordinates$Location[j] </span><br/><span style="font-family:Courier New;"> indices.1 &lt;- which(experimental.condition$Location == average.coordinates$Location[j]) </span><br/><span style="font-family:Courier New;"> raw.data$Location[indices.2] &lt;- experimental.condition$Location[indices.1]</span><br/><span style="font-family:Courier New;"> raw.data$ExpCondition[indices.2] &lt;- experimental.condition$ExpCondition[indices.1]</span><br/><span style="font-family:Courier New;"> raw.data$ExpID[indices.2] &lt;- experimental.condition$ExpID[indices.1]}</span><br/><span style="font-family:Courier New;"> if (length(which(raw.data$Location == 0)) == 0) {print("No 0s left and all coordinates are assigned a location")} else {"Watch out! There are unidentified particles left in the data."}</span><br/><span style="color:#009900;"><span style="font-family:Courier New;">#Loops over number of rows in average.coordinates file (</span><em><span style="font-family:Courier New;">i.e.</span></em><span style="font-family:Courier New;">, 72 rows for 72 particles). Returns the particle that falls within the X- , Y-coordinates for a specific position, </span><em><span style="font-family:Courier New;">i.e.</span></em><span style="font-family:Courier New;">, 110 particles for each location because there are 110 images. </span><em><span style="font-family:Courier New;">Note: small and not-centered particles may not be detected.</span></em><span style="font-family:Courier New;"> Relates the location number (</span><em><span style="font-family:Courier New;">i.e.</span></em><span style="font-family:Courier New;">, 1 to 72) to the X, Y position so that the particle has the same label on every image. Couples experimental conditions to locations. </span></span><br/><br/><span style="color:#009900;font-family:Courier New;"><u>####Transform the detected surface area of particles into equivalent diameters.</u></span><br/><br/><span style="color:#009900;font-family:Courier New;"><u>##Calculation of equivalent diameter from area --------------------------------------</u></span><br/><span style="font-family:Courier New;"> raw.data &lt;- cbind(raw.data, 2*sqrt(raw.data$Area/pi), rep(NA, nrow(raw.data)))</span><br/><span style="font-family:Courier New;"> colnames(raw.data)[(ncol(raw.data)-1):ncol(raw.data)] &lt;- c("EquivDiam_pix", </span><br/><span style="font-family:Courier New;"> "EquivDiam_cm") </span><br/><span style="color:#009900;font-family:Courier New;"><u>#Calculates diameter of particle area assuming that it represents a circle.</u></span><br/><span style="font-family:Courier New;"> raw.data$EquivDiam_cm &lt;- raw.data$EquivDiam_pix/scaling.factor</span><br/><span style="color:#009900;font-family:Courier New;">#Converts pixels to centimeters.</span><br/><br/><span style="color:#009900;font-family:Courier New;"><u>####Plot the average decrease in particle diameter per experimental condition over time.</u></span><br/><br/><span style="color:#009900;font-family:Courier New;">##Plot diameter over experimental time per experimental condition --------------------------------------</span><br/><span style="font-family:Courier New;"> treated.final.data &lt;- ddply(raw.data, c("ExpTime", "ExpID"), summarise,</span><br/><span style="font-family:Courier New;"> average.diameter = mean(EquivDiam_cm), sd.diameter = sd(EquivDiam_cm),sem.diameter= sd(EquivDiam_cm)/sqrt(length(EquivDiam_cm))) </span><br/><br/><span style="font-family:Courier New;"> treated.final.data$ExpID &lt;- as.character(treated.final.data$ExpID)</span><br/><span style="font-family:Courier New;"> average.diameter &lt;- treated.final.data$ average.diameter </span><br/><span style="font-family:Courier New;"> sd &lt;- treated.final.data$sd.diameter</span><br/><br/><span style="font-family:Courier New;"> p &lt;- ggplot(treated.final.data, mapping = aes(x=ExpTime, y= average.diameter, shape=ExpID, color=ExpID)) </span><br/><span style="font-family:Courier New;"> p &lt;- p + geom_point() </span><br/><span style="font-family:Courier New;"> p &lt;- p + scale_shape_discrete(name = "ExpID", breaks=c("1", "2"), labels=c("sludge1", "sludge2"))</span><br/><span style="font-family:Courier New;"> p &lt;- p + scale_color_discrete(name = "ExpID", breaks=c("1", "2"), labels=c("sludge1", "sludge2")) </span><br/><span style="font-family:Courier New;"> p &lt;- p + geom_errorbar(aes(ymin= average.diameter-sd, ymax= average.diameter+sd))</span><br/><span style="font-family:Courier New;"> p &lt;- p + labs(x = "Experimental time [h]", y = "Biomass diameter [cm]") </span><br/><span style="font-family:Courier New;"> p </span><span style="color:#009900;font-family:Courier New;">#This is Figure 8</span><span style="font-family:Courier New;">.</span><br/><br/></li><li>You can use your own generated files or you can run a demo with the files presented at <a href="https://doi.org/10.5281/zenodo.3938457" target="_blank">https://doi.org/10.5281/zenodo.3938457</a>.</li><li>Run the script by clicking on âRunâ.</li><li>Verify whether the generated plot (Figure 8) matches with what you would expect based on the experimental time-lapse images.<br/><br/><img alt="" class="layerphoto" loading="lazy" src="https://en-cdn.bio-protocol.org/attached/image/20200923/20200923195117_4955.jpg" width="300"/><br/><strong>Figure 8. Progression of photogranulation shown as biomass contraction, <em>i.e.</em>, decrease in diameter.</strong> Hydrotatic batch cultivations were started with two different sludge sources, each containing 36 replicates. Error bars present standard deviations.</li></ol></li></ol><br/>Progression of photogranulation as quantified by biomass contraction, <em>i.e.</em>, the decrease in diameter over time, is presented in Figure 8 for two different sludge sources. Initially, the sludge bed covers the entire bottom and corresponds to the inner diameter of the vial, <em>i.e.</em>, 1.27 cm. During successful photogranulation, a final diameter of about half the initial value or less can be expected. Here the biomass did not granulate well in all 36 replicates per sludge source, and the formation of microbial mats was observed. This large variation in degree of contraction, <em>i.e.</em>, the formation of two very different phenotypes, is reflected by the large standard deviations around the average diameters. Despite this heterogeneity, sludge source 2 resulted in more compact OPGs with a smaller average diameter than sludge source 1. Data was not obtained between 354 and 472 hours due to a technical issue.<br/><br/></li><li>Data exclusion<ol class="npwtwo"><li>Failed experiments (<em>e.g.</em>, overgrown vial bottoms, floating biomass, tipped vials) can be excluded manually from the analysis by removing the corresponding lines in the raw data or using a file specifying data points to be removed within the script (not described here).<br/><br/></li></ol></li><li>Statistical analysis <ol class="npwtwo"><li>Standard deviations around the average diameters of replicates are caculated at the end of the R script in Step E1b.</li></ol></li></ol><p class="pptt" id="biaoti36942">### Notes</p><p class="ppzz">The biological phenomenon of photogranulation is not always reproducible: success rates greatly vary and may depend on the inoculum (<em>i.e.</em>, the activated sludge) or experimental conditions, <em>e.g.</em>, temperature, light intensity or light quality. This variability is subject of ongoing research using this protocol.</p><p class="pptt" id="biaoti36943">### Acknowledgments</p><p class="ppzz">This work was funded by Graduate School GAIA of Montpellier University of Excellence (100% PhD fellowship for Esmee Joosten) and the ANR project PSST ANR- 16-CE04-0001.<br/>  Production of OPGs under hydrostatic batch conditions was earlier presented by Park &amp; Dolan (2015) and Milferstedt <em>et al.</em> (2017).</p><p class="pptt" id="biaoti36944">### Competing interests</p><p class="ppzz">The authors declare not to have any (non-)financial competing interests.</p><p class="pptt" id="biaoti36945">### References</p><ol class="npwtwok"><li>Abouhend, A. S., McNair, A., Kuo-Dahab, W. C., Watt, C., Butler, C. S., Milferstedt, K., Hamelin, J., Seo, J., Gikonyo, G. J., El-Moselhy, K. M. and Park, C. (2018). <a href="https://pubs.acs.org/doi/full/10.1021/acs.est.8b00403" target="_blank">The oxygenic photogranule process for aeration-free wastewater treatment.</a> <em>Environ Sci Technol</em> 52(6): 3503-3511.</li><li>Irvine-Fynn, T. D. L., Bridge, J. W. and Hodson, A. J. (2010). <a href="https://www.cambridge.org/core/journals/journal-of-glaciology/article/rapid-quantification-of-cryoconite-granule-geometry-and-in-situ-supraglacial-extents-using-examples-from-svalbard-and-greenland/F8D75AF2EF4B633CE14F169036379CAD" target="_blank">Rapid quantification of cryoconite: granule geometry and <em>in situ</em> supraglacial extents, using examples from Svalbard and Greenland.</a> <em>J Glaciol</em> 56(196): 297-308.</li><li>Legland, D., Arganda-Carreras, I. and Andrey, P. (2016). <a href="https://www.ncbi.nlm.nih.gov/pubmed/27412086" target="_blank">MorphoLibJ: Integrated library and plugins for mathematical morphology with ImageJ.</a> <em>Bioinformatics</em> 32(22): btw413.</li><li>Milferstedt, K., Kuo-Dahab, W. C., Butler, C. S., Hamelin, J., Abouhend, A. S., Stauch-White, K., McNair, A., Watt, C., Carbajal-GonzÃ¡lez, B. I., Dolan, S. and Park, C. (2017). <a href="https://www.ncbi.nlm.nih.gov/pubmed/29263358" target="_blank">The importance of filamentous cyanobacteria in the development of oxygenic photogranules.</a> <em>Sci Rep</em> 7(1): 17944.</li><li>OâBrien, J. (2020). exiftoolr: ExifTool Functionality from R. <a href="https://cran.r-project.org/package=exiftoolr" target="_blank">https://cran.r-project.org/package=exiftoolr</a> </li><li>Park, C. and Dolan, S. (2015). <a href="https://patents.google.com/patent/WO2015112654A3/en" target="_blank">Algal-sludge granule for wastewater treatment and bioenergy feedstock generation.</a> Pat Appl WO 2015112654 A2, Appl. number PCT/US2015/012332.</li><li>Quijano, G., Arcila, J. S. and BuitrÃ³n, G. (2017). <a href="https://www.sciencedirect.com/science/article/abs/pii/S0734975017300794?via%3Dihub" target="_blank">Microalgal-bacterial aggregates: Applications and perspectives for wastewater treatment.</a> <em>Biotechnol Adv</em> 35(6): 772-781.</li><li>R Core Team (2019). R: A language and environment for statistical computing. R Found. Stat. Comput. Vienna, Austria.</li><li>Schneider, C. A., Rasband, W. S. and Eliceiri, K. W. (2012). <a href="https://doi.org/10.1007/978-1-84882-087-6_9" target="_blank">ImageJ.</a> <em>Fundam Digit Imaging Med</em> 9(7): 185-188.</li><li>Wickham, H. (2016). <a href="https://ggplot2-book.org/" target="_blank">ggplot2: Elegant Graphics for Data Analysis.</a> Springer-Verlag New York.<br/></li><li>Wickham, H. (2011). <a href="https://www.jstatsoft.org/article/view/v040i01" target="_blank">The split-apply-combine strategy for data analysis.</a> <em>J Stat Software</em> 40(1): 1-29.</li><li>Wickham, H., Hester, J., Francois, R. (2018) readr: Read Rectangular Text Data. <a href="https://cran.r-project.org/packaga=readr" target="_blank">https://cran.r-project.org/package=readr</a><br/></li></ol>